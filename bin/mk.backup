#! /bin/bash

# $HOME/.local/bin/tarcrypt
# Author: MrJcsh
# 20 December, 2025
# Tested with: Bash 5.2.15(1)-release (ChromeOS)
#              OpenSSL 3.0.17 July 1st, 2025
#              tar (GNU tar) 1.34

# Purpose: To permit the creation of tar archives of a given(or from cwd)
#+  directory and give the option to encrypt the archive. This should, in
#+  addtion, inverse of both options allowing for recovery of the archives.

# Notes: For the point and purpose of using things as close to vanilla tools
#+  that one can typically find on a modern Linux distro, I am avoiding the 
#+  revision steps of including madness, like including Argon2. With that said,
#+  I'm applying a x20 iteration count to the default of 10,000 iterations to
#+  the key derivation step. Also, I am electing to use AES-256-CBC, as it is
#+  more agreeable to use against a tar file. You'll also notice that archives
#+  that end up encrypted, do not touch the disk. Live OS? Is it that sensitive?
#+  Am I sensitive to disk writes?

# Notes: AES-256-CBC provides confidentiality, it does not provide integrity
#+  SHA protects the ciphertext, not authenticated encryption. An attacker could
#+  still flip bits and cause garbage extraction(detected only after).


set -euo pipefail

#QUIET='false'
# Functions
function usage() {

  echo "Usage: tarcrypt [ [-e|-u] -a|-x ] <source> <destination>"
  echo "       -e         Encryption to be performed on archive."
  echo "       -u         Un-Encryption to be performed on archive."
  echo "       -a         Default: Implied if no other arguments other than"
  echo "                  target source, and target destination."
  echo "       -x         eXtract archive source to destination."
  echo "       -q         Suppresses output."
  echo
  echo " SHA256 hash files are created for verification."
  echo " default targets are:"
  echo "        source = Current Working Directory."
  echo "   destination = /var/backups/'$USER'/YYYY-MM-DD_HHMMSS.Basename.tar.gz"
  echo

  exit 0

}

function get_confirm() {

  [ "$QUIET" != "true" ] && echo -e "Are you sure? [y/N]\c"
  while :; do

    [ "$QUIET" != "true" ] && { \
      read u_input
      case "$u_input" in

        y | yes | Y | Yes | YES ) return 0 ;;
        n | no | N | No | NO )
        echo "Dropping back to shell. Please, verify work and, try again!"
        exit 0 ;;
        * ) echo "Please enter yes, or no" ;;

    esac } || exit 127

  done

}

function mk.tarchive() {

  # Contract:
  # - input: filesystem path
  # - output: '*.tar.gz' file
  local SRC="$1"
  local OUT="$2"

  tar -czvf "$OUT" "$SRC"&& sha256sum "$OUT" > "${OUT}.sha256" || return 1

  [ "$QUIET" != "true" ] && echo "Archive created: $OUT"

  return 0

}

function mk.tarcrypt() {

  # Contract:
  # - input: filesystem path
  # - output: '*.tar.gz.enc' file
  #   - password protected
  #   - no plaintext on disk
  local SRC="$1"
  local OUT="$2"
  local SHA_FILE="${OUT}.sha256"

  tar -czf - "$SRC" \
    | openssl enc -aes-256-cbc -salt -pbkdf2 -iter 200000 > "$OUT" || return 1
  
  [ "$QUIET" != "true" ] && echo "Encrypted archive created: $OUT"

  sha256sum "$OUT" > "${SHA_FILE}"

  [ "$QUIET" != "true" ] && echo "sha256 file for archive created: $SHA_FILE"

  return 0

}

function ex.tarchive() {

  # Contract:
  # - input: '*.tar.gz' file
  # - output: restored filesystem tree
  local ARC="$1"
  local OUT="$2"

  SHA_FILE="${ARC}.sha256"
  if [ ! -f "$SHA_FILE" ]; then

    # SHA file does not exist, get confirmation from user if they would like to
    # carry on, as it's possible they have preserved the .sha256 file somewhere
    # else.
    echo "$SHA_FILE file not found. Would you like to continue?"
    get_confirm && sha256sum "$ARC"

  else

    # SHA file found, perform check and continue
    sha256sum -c "$SHA_FILE" && { \
      [ "$QUIET" != "true" ] && { echo "Verification passed!"; }; } || { \
      [ "$QUIET" != "true" ] && { echo "Verification failed!"; }; exit 2; }

  fi

  tar -xzf "$ARC" -C "$OUT" || return 1

  [ "$QUIET" != "true" ] && echo "Archive extracted: $OUT"

  return 0

}

function ex.tarcrypt() {

  # Contract:
  # - input: '*.tar.gz.enc' file
  #   - password demanded by openssl
  # - output: restored filesystem tree
  local ARC="$1"
  local OUT="$2"

  SHA_FILE="${ARC}.sha256"
  if [ ! -f "$SHA_FILE" ]; then

    # SHA file does not exist, get confirmation from user if they would like to
    # carry on, as it's possible they have preserved the .sha256 file somewhere
    # else.
    echo "$SHA_FILE file not found. Would you like to continue?"
    get_confirm && sha256sum "$ARC"

  else

    # SHA file found, perform check and continue
    sha256sum -c "$SHA_FILE" && { \
      [ "$QUIET" != "true" ] && { echo "Verification passed!"; }; } || { \
      [ "$QUIET" != "true" ] && { echo "Verification failed!"; }; exit 2; }

  fi

  openssl enc -d -aes-256-cbc -pbkdf2 -iter 200000 -in "$ARC" \
    | tar -xzf - -C "$OUT"

  [ "$QUIET" != "true" ] && { \
    echo "Encrypted archive successfully extracted: $OUT"; }

  return 0

}

# Variables
QUIET='false'
MODE='archive'
ACTION='archive'
DATE="$( date +%Y-%m-%d_%H%M%S )"
# Parse options
while getopts ":euaxq" opt; do

  case "$opt" in

    e) MODE='encrypt' ACTION='archive'   ;;
    u) MODE='decrypt' ACTION='extract'   ;;
    a) MODE='archive' ACTION='archive'  ;;
    x) MODE='archive' ACTION='extract' ;;
    q) QUIET='true'     ;;
    *) usage            ;;

  esac

done
shift $((OPTIND - 1))

BACKUP_SRC="$PWD"
BACKUP_DST="/var/backups/$USER"
[[ $# -eq 0 ]] && usage
[[ $# -ge 1 ]] && BACKUP_SRC="${1}"
[[ $# -ge 2 ]] && BACKUP_DST="${2}"
BASENAME="$( basename ${BACKUP_SRC} )"
COMPRESSED="${BACKUP_DST}/${DATE}.${BASENAME}.tar.gz"
ENCRYPTED="${COMPRESSED}.enc"


echo "$MODE:$ACTION"

case $MODE:$ACTION in

  encrypt:archive ) mk.tarcrypt "${BACKUP_SRC}" "${ENCRYPTED}"  ;;
  decrypt:extract ) ex.tarcrypt "${BACKUP_SRC}" "${BACKUP_DST}" ;;
  archive:archive ) mk.tarchive "${BACKUP_SRC}" "${COMPRESSED}" ;;
  archive:extract ) ex.tarchive "${BACKUP_SRC}" "${BACKUP_DST}" ;;

  * ) echo "Invalid option combination"; usage; ;;

esac
